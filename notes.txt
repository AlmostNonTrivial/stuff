/*
** bplustree.cpp - B+Tree implementation for educational SQL engine
**
** This file implements a B+Tree data structure optimized for disk-based
** storage using the pager module. The implementation follows traditional
** B+Tree semantics where all data is stored in leaf nodes and internal
** nodes contain only separator keys and child pointers.
**
** DESIGN PRINCIPLES:
**
** 1. **Page-Aligned Nodes**: Each B+Tree node occupies exactly one page,
**    maximizing I/O efficiency and cache utilization.
**
** 2. **Leaf-Only Data Storage**: Following classic B+Tree design, all
**    records are stored in leaf nodes. Internal nodes contain only keys
**    and child pointers, maximizing fanout and minimizing tree height.
**
** 3. **Linked Leaf Chain**: Leaf nodes are doubly-linked for efficient
**    range scans and cursor traversal without tree re-traversal.
**
** 4. **Lazy Deletion**: The delete operation uses lazy consolidation,
**    allowing temporary underflow to minimize write amplification.
**
** 5. **Top-Down Splitting**: Nodes are split proactively during insertion
**    descent when full, avoiding the need for parent pointers during insert.
**
** IMPLEMENTATION NOTES:
**
** - The implementation assumes single-threaded access. Concurrency control
**   must be handled at a higher level.
** - All modifications require an active pager transaction.
** - Node underflow is permitted temporarily but repaired on next access.
*/

#include "btree.hpp"
#include "arena.hpp"
#include "defs.hpp"
#include "types.hpp"
#include "pager.hpp"
#include <cassert>
#include <cstdint>
#include <cstring>

/*
** NODE STRUCTURE AND LAYOUT
**
** Each B+Tree node is exactly PAGE_SIZE bytes and contains:
**
** Header (24 bytes):
**   - index: Page number in the data file (4 bytes)
**   - parent: Parent page index, 0 for root (4 bytes)
**   - next: Next sibling for leaf chain traversal (4 bytes)
**   - previous: Previous sibling for leaf chain (4 bytes)
**   - num_keys: Current number of keys in node (4 bytes)
**   - is_leaf: Node type flag (4 bytes, includes padding)
**
** Data Area (PAGE_SIZE - 24 bytes):
**   Internal nodes: [K0|K1|...|Kn][C0|C1|...|Cn+1]
**                   Keys followed by child pointers
**   Leaf nodes:     [K0|K1|...|Kn][R0|R1|...|Rn]
**                   Keys followed by records
**
** The maximum number of entries per node depends on key and record sizes,
** calculated during tree creation to ensure optimal page utilization.
*/

#define NODE_HEADER_SIZE 24
#define NODE_DATA_SIZE   (PAGE_SIZE - NODE_HEADER_SIZE)
#define MIN_ENTRY_COUNT  3  /* Minimum entries for tree viability */

struct BTreeNode {
    uint32_t index;     /* Self-identifying page number */
    uint32_t parent;    /* Parent node page (0 = root) */
    uint32_t next;      /* Next leaf in chain (leaves only) */
    uint32_t previous;  /* Previous leaf in chain (leaves only) */
    uint32_t num_keys;  /* Active key count in this node */
    uint32_t is_leaf;   /* Node type: 1=leaf, 0=internal */
    uint8_t  data[NODE_DATA_SIZE];  /* Keys, records/children */
};

static_assert(sizeof(BTreeNode) == PAGE_SIZE,
              "BTreeNode must exactly match page size");

/* ============================================================================
** ACCESSOR MACROS
**
** These macros provide type-safe access to node data while maintaining
** memory layout abstraction. They compute offsets based on the tree's
** configuration (key size, record size, max entries).
** ============================================================================ */

/* Node type predicates */
#define IS_LEAF(node)     ((node)->is_leaf)
#define IS_INTERNAL(node) (!(node)->is_leaf)
#define IS_ROOT(node)     ((node)->parent == 0)

/* Capacity calculations based on node type */
#define GET_MAX_KEYS(node)    \
    (IS_LEAF(node) ? tree->leaf_max_keys : tree->internal_max_keys)
#define GET_MIN_KEYS(node)    \
    (IS_LEAF(node) ? tree->leaf_min_keys : tree->internal_min_keys)
#define GET_SPLIT_INDEX(node) \
    (IS_LEAF(node) ? tree->leaf_split_index : tree->internal_split_index)

/* Node retrieval through pager */
#define GET_NODE(index)   (reinterpret_cast<BTreeNode*>(pager_get(index)))
#define GET_ROOT()        GET_NODE(tree->root_page_index)
#define GET_PARENT(node)  GET_NODE((node)->parent)
#define GET_NEXT(node)    GET_NODE((node)->next)
#define GET_PREV(node)    GET_NODE((node)->previous)

/* Memory layout accessors for keys and data */
#define GET_KEY_AT(node, idx) \
    ((node)->data + (idx) * tree->node_key_size)

/* Internal node children array starts after all keys */
#define GET_CHILDREN(node) \
    (reinterpret_cast<uint32_t*>((node)->data + \
     tree->internal_max_keys * tree->node_key_size))
#define GET_CHILD(node, idx) \
    GET_NODE(GET_CHILDREN(node)[idx])

/* Leaf node records start after all keys */
#define GET_RECORD_DATA(node) \
    ((node)->data + tree->leaf_max_keys * tree->node_key_size)
#define GET_RECORD_AT(node, idx) \
    (GET_RECORD_DATA(node) + (idx) * tree->record_size)

/* Node state predicates for split/merge decisions */
#define NODE_IS_FULL(node)     ((node)->num_keys >= GET_MAX_KEYS(node))
#define NODE_IS_MINIMAL(node)  ((node)->num_keys <= GET_MIN_KEYS(node))
#define IS_UNDERFLOWING(node)  ((node)->num_keys < GET_MIN_KEYS(node))
#define NODE_CAN_SPARE(node)   ((node)->num_keys > GET_MIN_KEYS(node))

/* Transaction integration */
#define MARK_DIRTY(node) pager_mark_dirty((node)->index)

/* ============================================================================
** MEMORY OPERATIONS
**
** Efficient block memory operations for shifting and copying node data.
** These maintain proper memory alignment and handle overlapping regions.
** ============================================================================ */

/* Shift operations for making room or closing gaps */
#define SHIFT_KEYS_RIGHT(node, from, count) \
    memcpy(GET_KEY_AT(node, (from) + 1), \
            GET_KEY_AT(node, from), \
            (count) * tree->node_key_size)

#define SHIFT_KEYS_LEFT(node, to, count) \
    memcpy(GET_KEY_AT(node, to), \
            GET_KEY_AT(node, (to) + 1), \
            (count) * tree->node_key_size)

#define SHIFT_RECORDS_RIGHT(node, from, count) \
    memcpy(GET_RECORD_AT(node, (from) + 1), \
            GET_RECORD_AT(node, from), \
            (count) * tree->record_size)

#define SHIFT_RECORDS_LEFT(node, to, count) \
    memcpy(GET_RECORD_AT(node, to), \
            GET_RECORD_AT(node, (to) + 1), \
            (count) * tree->record_size)

#define SHIFT_CHILDREN_RIGHT(node, from, count) \
    memcpy(&GET_CHILDREN(node)[(from) + 1], \
            &GET_CHILDREN(node)[from], \
            ((count) + 1) * sizeof(uint32_t))

#define SHIFT_CHILDREN_LEFT(node, to, count) \
    memcpy(&GET_CHILDREN(node)[to], \
            &GET_CHILDREN(node)[(to) + 1], \
            ((count) + 1) * sizeof(uint32_t))

/* Copy operations for split/merge */
#define COPY_KEY(dest, src) \
    memcpy(dest, src, tree->node_key_size)

#define COPY_RECORD(dest, src) \
    memcpy(dest, src, tree->record_size)

#define COPY_KEYS(src_node, src_idx, dest_node, dest_idx, count) \
    memcpy(GET_KEY_AT(dest_node, dest_idx), \
           GET_KEY_AT(src_node, src_idx), \
           (count) * tree->node_key_size)

#define COPY_RECORDS(src_node, src_idx, dest_node, dest_idx, count) \
    memcpy(GET_RECORD_AT(dest_node, dest_idx), \
           GET_RECORD_AT(src_node, src_idx), \
           (count) * tree->record_size)

/* ============================================================================
** UTILITY FUNCTIONS
**
** Low-level operations for node management, searching, and maintenance.
** ============================================================================ */

/*
** Find a child's index within its parent's children array.
** Used during split/merge operations to locate siblings.
**
** Returns: Index in parent's children array, or UINT32_MAX if not found.
*/
static uint32_t find_child_index(BTree* tree, BTreeNode* parent, BTreeNode* child) {
    uint32_t* children = GET_CHILDREN(parent);
    for (uint32_t i = 0; i <= parent->num_keys; i++) {
        if (children[i] == child->index) {
            return i;
        }
    }
    assert(false);  /* Child must exist in parent */
    return UINT32_MAX;
}

/*
** Update the linked list pointers for leaf nodes.
** Maintains the doubly-linked chain for efficient range scans.
**
** NOTE: This is a no-op for internal nodes, which don't participate
** in the leaf chain.
*/
static void link_leaf_nodes(BTreeNode* left, BTreeNode* right) {
    if (left) {
        MARK_DIRTY(left);
        left->next = right ? right->index : 0;
    }
    if (right) {
        MARK_DIRTY(right);
        right->previous = left ? left->index : 0;
    }
}

/*
** Remove a leaf node from the sibling chain.
** Called before deleting a leaf node to maintain chain integrity.
*/
static void unlink_leaf_node(BTreeNode* node) {
    if (!IS_LEAF(node)) return;

    BTreeNode* prev_node = nullptr;
    BTreeNode* next_node = nullptr;

    if (node->previous != 0) {
        prev_node = GET_PREV(node);
    }
    if (node->next != 0) {
        next_node = GET_NEXT(node);
    }

    link_leaf_nodes(prev_node, next_node);
}

/*
** Set a child pointer and update the child's parent pointer.
** Maintains bidirectional parent-child relationships.
**
** NOTE: Always marks both nodes as dirty for transaction consistency.
*/
static void set_child(BTree* tree, BTreeNode* parent,
                     uint32_t child_slot, uint32_t child_index) {
    assert(IS_INTERNAL(parent));

    MARK_DIRTY(parent);
    uint32_t* children = GET_CHILDREN(parent);
    children[child_slot] = child_index;

    if (child_index != 0) {
        BTreeNode* child = GET_NODE(child_index);
        if (child) {
            MARK_DIRTY(child);
            child->parent = parent->index;
        }
    }
}

/* ============================================================================
** SEARCH ALGORITHM
**
** Binary search implementation optimized for B+Tree semantics.
** For leaf nodes: Returns exact match position or insertion point.
** For internal nodes: Returns child pointer index for descent.
** ============================================================================ */

/*
** Perform binary search on a node's keys.
**
** Returns:
**   - For leaf nodes: Index of matching key or insertion position
**   - For internal nodes: Child index to follow for descent
**
** NOTE: The search behavior differs between node types to handle
** duplicate keys correctly during tree traversal.
*/
static uint32_t binary_search(BTree* tree, BTreeNode* node, void* key) {
    uint32_t left = 0;
    uint32_t right = node->num_keys;

    while (left < right) {
        uint32_t mid = left + (right - left) / 2;
        void* mid_key = GET_KEY_AT(node, mid);

        if (type_less_than(tree->node_key_type, mid_key, key)) {
            left = mid + 1;
        } else if (type_equals(tree->node_key_type, mid_key, key)) {
            /* Exact match found */
            if (IS_LEAF(node)) {
                return mid;  /* Return exact position in leaf */
            }
            return mid + 1;  /* Go right in internal node */
        } else {
            right = mid;
        }
    }

    return left;  /* Insertion point or child index */
}

/*
** Find the leaf node that should contain a given key.
** Performs root-to-leaf traversal using binary search at each level.
*/
static BTreeNode* find_leaf_for_key(BTree* tree, void* key) {
    BTreeNode* node = GET_ROOT();

    while (IS_INTERNAL(node)) {
        uint32_t idx = binary_search(tree, node, key);
        node = GET_CHILD(node, idx);
    }

    return node;
}

/* ============================================================================
** NODE CREATION AND DESTRUCTION
**
** Lifecycle management for B+Tree nodes with pager integration.
** ============================================================================ */

/*
** Allocate and initialize a new B+Tree node.
**
** Parameters:
**   tree: The B+Tree structure
**   is_leaf: true for leaf node, false for internal node
**
** Returns: Pointer to the newly created node (never nullptr).
**
** NOTE: Requires an active transaction. The node is immediately
** marked dirty to ensure it's written to disk on commit.
*/
static BTreeNode* create_node(BTree* tree, bool is_leaf) {
    uint32_t page_index = pager_new();
    assert(page_index != PAGE_INVALID);

    BTreeNode* node = GET_NODE(page_index);

    /* Initialize node header */
    node->index = page_index;
    node->parent = 0;
    node->next = 0;
    node->previous = 0;
    node->num_keys = 0;
    node->is_leaf = is_leaf ? 1 : 0;

    MARK_DIRTY(node);
    return node;
}

/*
** Destroy a node and return its page to the free list.
** Handles unlinking from leaf chain if applicable.
*/
static void destroy_node(BTreeNode* node) {
    unlink_leaf_node(node);
    pager_delete(node->index);
}

/* ============================================================================
** ROOT MANAGEMENT
**
** Special handling for root node operations to maintain tree invariants.
** ============================================================================ */

/*
** Swap the contents of the root with another node.
**
** This operation is used when:
** 1. Creating a new root during split operations
** 2. Collapsing the root when it becomes empty
**
** The swap preserves page indices while exchanging content, ensuring
** the root always remains at its designated page index.
*/
static void swap_with_root(BTree* tree, BTreeNode* root, BTreeNode* other) {
    MARK_DIRTY(root);
    MARK_DIRTY(other);

    assert(root->index == tree->root_page_index);

    /* Save original indices */
    uint32_t saved_root_index = root->index;
    uint32_t saved_other_index = other->index;

    /* Swap all content */
    BTreeNode temp;
    memcpy(&temp, other, sizeof(BTreeNode));
    memcpy(other, root, sizeof(BTreeNode));
    memcpy(root, &temp, sizeof(BTreeNode));

    /* Restore original indices */
    root->index = saved_root_index;
    other->index = saved_other_index;

    /* Fix parent pointers for root's new children */
    root->parent = 0;  /* Root has no parent */

    if (IS_INTERNAL(root)) {
        uint32_t* children = GET_CHILDREN(root);
        for (uint32_t i = 0; i <= root->num_keys; i++) {
            if (children[i]) {
                BTreeNode* child = GET_NODE(children[i]);
                MARK_DIRTY(child);
                child->parent = tree->root_page_index;
            }
        }
    }
}

/*
** Collapse an empty root node (internal nodes only).
**
** When the root has only one child remaining after deletion,
** that child becomes the new root to reduce tree height.
*/
static void collapse_empty_root(BTree* tree, BTreeNode* root) {
    assert(root->num_keys == 0);
    assert(IS_INTERNAL(root));

    BTreeNode* only_child = GET_CHILD(root, 0);

    /* Make child the new root */
    swap_with_root(tree, root, only_child);

    /* Delete the old root (now at child's position) */
    destroy_node(only_child);
}

/* ============================================================================
** SPLIT OPERATION
**
** Node splitting for overflow handling during insertion.
** Creates a new sibling and promotes a separator key to parent.
** ============================================================================ */

/*
** Split a full node into two nodes.
**
** Algorithm:
** 1. Create new right sibling
** 2. Distribute keys/children between nodes
** 3. Promote middle key to parent
** 4. Update all pointers and links
**
** Returns: Parent node (which may now need splitting itself)
**
** NOTE: If splitting the root, a new root is created above it.
*/
static BTreeNode* split(BTree* tree, BTreeNode* node) {
    uint32_t split_point = GET_SPLIT_INDEX(node);
    BTreeNode* new_right = create_node(tree, IS_LEAF(node));

    /* Save the key that will be promoted */
    uint8_t promoted_key[256];
    COPY_KEY(promoted_key, GET_KEY_AT(node, split_point));

    MARK_DIRTY(node);
    MARK_DIRTY(new_right);

    /* Ensure parent exists (create new root if needed) */
    BTreeNode* parent = GET_PARENT(node);
    uint32_t position_in_parent = 0;

    if (!parent) {
        /* Splitting root - create new root above */
        BTreeNode* new_node = create_node(tree, false);
        BTreeNode* root = GET_NODE(tree->root_page_index);

        /* Swap contents: root becomes empty parent */
        swap_with_root(tree, root, new_node);

        /* Set up new root with single child */
        set_child(tree, root, 0, new_node->index);

        parent = root;
        node = new_node;
        position_in_parent = 0;
    } else {
        /* Find our position in existing parent */
        position_in_parent = find_child_index(tree, parent, node);

        /* Make room in parent */
        SHIFT_CHILDREN_RIGHT(parent, position_in_parent + 1,
                           parent->num_keys - position_in_parent);
        SHIFT_KEYS_RIGHT(parent, position_in_parent,
                        parent->num_keys - position_in_parent);
    }

    /* Insert promoted key into parent */
    MARK_DIRTY(parent);
    COPY_KEY(GET_KEY_AT(parent, position_in_parent), promoted_key);
    set_child(tree, parent, position_in_parent + 1, new_right->index);
    parent->num_keys++;

    /* Split the node's data */
    if (IS_LEAF(node)) {
        /* Leaf: Simple split of keys and records */
        new_right->num_keys = node->num_keys - split_point;
        COPY_KEYS(node, split_point, new_right, 0, new_right->num_keys);
        COPY_RECORDS(node, split_point, new_right, 0, new_right->num_keys);

        /* Maintain leaf chain */
        link_leaf_nodes(new_right, GET_NEXT(node));
        link_leaf_nodes(node, new_right);

        node->num_keys = split_point;
    } else {
        /* Internal: Promoted key goes up, doesn't stay in either node */
        new_right->num_keys = node->num_keys - split_point - 1;
        COPY_KEYS(node, split_point + 1, new_right, 0, new_right->num_keys);

        /* Move children to new right node */
        uint32_t* left_children = GET_CHILDREN(node);
        for (uint32_t i = 0; i <= new_right->num_keys; i++) {
            uint32_t child = left_children[split_point + 1 + i];
            if (child) {
                set_child(tree, new_right, i, child);
                left_children[split_point + 1 + i] = 0;
            }
        }

        node->num_keys = split_point;
    }

    return parent;
}

/* ============================================================================
** INSERTION ALGORITHM
**
** Top-down insertion with proactive splitting.
** ============================================================================ */

/*
** Insert a key-value pair into the B+Tree.
**
** Algorithm:
** 1. Handle empty tree special case
** 2. Find target leaf node
** 3. Split nodes proactively if full (may cascade up)
** 4. Insert into leaf with room
**
** NOTE: Requires an active transaction. Duplicate keys are not allowed
** in the current implementation.
*/
static void insert_element(BTree* tree, void* key, void* data) {
    BTreeNode* root = GET_ROOT();

    /* Handle empty tree */
    if (root->num_keys == 0) {
        MARK_DIRTY(root);
        COPY_KEY(GET_KEY_AT(root, 0), key);
        COPY_RECORD(GET_RECORD_AT(root, 0), data);
        root->num_keys = 1;
        return;
    }

    /* Find target leaf */
    BTreeNode* leaf = find_leaf_for_key(tree, key);

    /* Proactive splitting - split full nodes before insertion */
    if (NODE_IS_FULL(leaf)) {
        BTreeNode* node = leaf;
        while (node && NODE_IS_FULL(node)) {
            BTreeNode* parent = split(tree, node);
            node = IS_ROOT(parent) ? nullptr : parent;
        }

        /* Re-find leaf after splits */
        leaf = find_leaf_for_key(tree, key);
    }

    /* Insert into leaf */
    uint32_t pos = binary_search(tree, leaf, key);
    MARK_DIRTY(leaf);

    /* Shift existing entries right */
    SHIFT_KEYS_RIGHT(leaf, pos, leaf->num_keys - pos);
    SHIFT_RECORDS_RIGHT(leaf, pos, leaf->num_keys - pos);

    /* Insert new entry */
    COPY_KEY(GET_KEY_AT(leaf, pos), key);
    COPY_RECORD(GET_RECORD_AT(leaf, pos), data);
    leaf->num_keys++;
}

/* ============================================================================
** DELETION AND REPAIR OPERATIONS
**
** Bottom-up deletion with lazy repair. Underflow is tolerated temporarily
** and fixed through borrowing or merging when necessary.
** ============================================================================ */

/*
** Borrow an entry from left sibling to fix underflow.
**
** For leaves: Moves rightmost entry from left sibling.
** For internal nodes: Rotates through parent separator.
*/
static void borrow_from_left_sibling(BTree* tree, BTreeNode* node,
                                    BTreeNode* left_sibling,
                                    uint32_t separator_index) {
    BTreeNode* parent = GET_PARENT(node);

    MARK_DIRTY(node);
    MARK_DIRTY(left_sibling);
    MARK_DIRTY(parent);

    /* Make room at beginning of node */
    SHIFT_KEYS_RIGHT(node, 0, node->num_keys);

    if (IS_LEAF(node)) {
        /* Direct transfer for leaves */
        SHIFT_RECORDS_RIGHT(node, 0, node->num_keys);

        /* Move last entry from left to first of node */
        COPY_KEY(GET_KEY_AT(node, 0),
                GET_KEY_AT(left_sibling, left_sibling->num_keys - 1));
        COPY_RECORD(GET_RECORD_AT(node, 0),
                   GET_RECORD_AT(left_sibling, left_sibling->num_keys - 1));

        /* Update parent separator */
        COPY_KEY(GET_KEY_AT(parent, separator_index), GET_KEY_AT(node, 0));
    } else {
        /* Rotation through parent for internal nodes */

        /* Parent separator moves down to node */
        COPY_KEY(GET_KEY_AT(node, 0), GET_KEY_AT(parent, separator_index));

        /* Left's last key moves up to parent */
        COPY_KEY(GET_KEY_AT(parent, separator_index),
                GET_KEY_AT(left_sibling, left_sibling->num_keys - 1));

        /* Move corresponding child pointer */
        uint32_t* node_children = GET_CHILDREN(node);
        uint32_t* left_children = GET_CHILDREN(left_sibling);

        /* Shift node's children right */
        for (uint32_t i = node->num_keys + 1; i > 0; i--) {
            set_child(tree, node, i, node_children[i - 1]);
        }

        /* Add left's last child as first child of node */
        set_child(tree, node, 0, left_children[left_sibling->num_keys]);
    }

    node->num_keys++;
    left_sibling->num_keys--;
}

/*
** Borrow an entry from right sibling to fix underflow.
** Symmetric to borrow_from_left_sibling.
*/
static void borrow_from_right_sibling(BTree* tree, BTreeNode* node,
                                     BTreeNode* right_sibling,
                                     uint32_t separator_index) {
    BTreeNode* parent = GET_PARENT(node);

    MARK_DIRTY(node);
    MARK_DIRTY(right_sibling);
    MARK_DIRTY(parent);

    if (IS_LEAF(node)) {
        /* Direct transfer for leaves */
        COPY_KEY(GET_KEY_AT(node, node->num_keys), GET_KEY_AT(right_sibling, 0));
        COPY_RECORD(GET_RECORD_AT(node, node->num_keys),
                   GET_RECORD_AT(right_sibling, 0));

        /* Shift right sibling's entries left */
        SHIFT_KEYS_LEFT(right_sibling, 0, right_sibling->num_keys - 1);
        SHIFT_RECORDS_LEFT(right_sibling, 0, right_sibling->num_keys - 1);

        /* Update parent separator */
        COPY_KEY(GET_KEY_AT(parent, separator_index),
                GET_KEY_AT(right_sibling, 0));
    } else {
        /* Rotation through parent for internal nodes */

        /* Parent separator moves down to node */
        COPY_KEY(GET_KEY_AT(node, node->num_keys),
                GET_KEY_AT(parent, separator_index));

        /* Right's first key moves up to parent */
        COPY_KEY(GET_KEY_AT(parent, separator_index),
                GET_KEY_AT(right_sibling, 0));

        /* Move corresponding child pointer */
        uint32_t* right_children = GET_CHILDREN(right_sibling);
        set_child(tree, node, node->num_keys + 1, right_children[0]);

        /* Shift right's keys and children left */
        SHIFT_KEYS_LEFT(right_sibling, 0, right_sibling->num_keys - 1);
        for (uint32_t i = 0; i < right_sibling->num_keys; i++) {
            set_child(tree, right_sibling, i, right_children[i + 1]);
        }
    }

    node->num_keys++;
    right_sibling->num_keys--;
}

/*
** Attempt to borrow from either sibling to fix underflow.
** Returns true if borrowing succeeded, false if merge is needed.
*/
static bool try_borrow_from_siblings(BTree* tree, BTreeNode* node) {
    BTreeNode* parent = GET_PARENT(node);
    uint32_t child_index = find_child_index(tree, parent, node);

    /* Try left sibling first */
    if (child_index > 0) {
        BTreeNode* left = GET_CHILD(parent, child_index - 1);
        if (NODE_CAN_SPARE(left)) {
            borrow_from_left_sibling(tree, node, left, child_index - 1);
            return true;
        }
    }

    /* Try right sibling */
    if (child_index < parent->num_keys) {
        BTreeNode* right = GET_CHILD(parent, child_index + 1);
        if (NODE_CAN_SPARE(right)) {
            borrow_from_right_sibling(tree, node, right, child_index);
            return true;
        }
    }

    return false;
}

/*
** Merge an underflowing node with a sibling.
**
** Combines two nodes and removes the separator from parent.
** May cause parent to underflow, requiring recursive repair.
**
** Returns: Parent node that may need repair.
*/
static BTreeNode* perform_merge_with_sibling(BTree* tree, BTreeNode* node) {
    BTreeNode* parent = GET_PARENT(node);
    uint32_t child_index = find_child_index(tree, parent, node);

    BTreeNode *left, *right;
    uint32_t separator_index;

    /* Choose merge direction */
    if (child_index < parent->num_keys) {
        /* Merge with right sibling */
        left = node;
        right = GET_CHILD(parent, child_index + 1);
        separator_index = child_index;
    } else if (child_index > 0) {
        /* Merge with left sibling */
        left = GET_CHILD(parent, child_index - 1);
        right = node;
        separator_index = child_index - 1;
    } else {
        assert(false);  /* Node must have a sibling */
        return nullptr;
    }

    /* Perform merge */
    MARK_DIRTY(left);
    MARK_DIRTY(parent);

    if (IS_LEAF(left)) {
        /* Simple concatenation for leaves */
        COPY_KEYS(right, 0, left, left->num_keys, right->num_keys);
        COPY_RECORDS(right, 0, left, left->num_keys, right->num_keys);
        left->num_keys += right->num_keys;

        /* Update leaf chain */
        link_leaf_nodes(left, GET_NEXT(right));
    } else {
        /* Bring down separator and merge for internal nodes */

        /* Copy separator from parent */
        COPY_KEY(GET_KEY_AT(left, left->num_keys),
                GET_KEY_AT(parent, separator_index));

        /* Copy all keys from right */
        COPY_KEYS(right, 0, left, left->num_keys + 1, right->num_keys);

        /* Move all children from right */
        uint32_t* right_children = GET_CHILDREN(right);
        for (uint32_t i = 0; i <= right->num_keys; i++) {
            set_child(tree, left, left->num_keys + 1 + i, right_children[i]);
        }

        left->num_keys += 1 + right->num_keys;
    }

    /* Remove separator and right child from parent */
    SHIFT_KEYS_LEFT(parent, separator_index,
                   parent->num_keys - separator_index - 1);
    SHIFT_CHILDREN_LEFT(parent, separator_index + 1,
                       parent->num_keys - separator_index - 1);
    parent->num_keys--;

    /* Delete merged node */
    destroy_node(right);

    return parent;
}

/*
** Repair an underflowing node after deletion.
**
** Strategy:
** 1. Try borrowing from siblings (non-destructive)
** 2. If that fails, merge with a sibling (destructive)
** 3. Recursively repair parent if needed
** 4. Handle root collapse if it becomes empty
*/
static void repair_underflow(BTree* tree, BTreeNode* node) {
    /* Check if repair is needed */
    if (!IS_UNDERFLOWING(node)) {
        return;
    }

    /* Root is allowed to have fewer keys */
    if (IS_ROOT(node)) {
        return;
    }

    /* Try borrowing first (preserves node) */
    if (try_borrow_from_siblings(tree, node)) {
        return;
    }

    /* Resort to merging */
    BTreeNode* parent = perform_merge_with_sibling(tree, node);

    /* Check if parent needs repair */
    if (parent && IS_UNDERFLOWING(parent)) {
        if (IS_ROOT(parent) && parent->num_keys == 0) {
            collapse_empty_root(tree, parent);
        } else {
            repair_underflow(tree, parent);
        }
    }
}

/*
** Delete an entry from a leaf node.
**
** Simple removal with gap closure. May trigger underflow repair.
*/
static void delete_element(BTree* tree, BTreeNode* leaf, uint32_t index) {
assert(IS_LEAF(node));

	// Special case: deleting last entry from root leaf
	if (IS_ROOT(node) && node->num_keys == 1)
	{
		MARK_DIRTY(node);
		node->num_keys = 0;
		return;
	}
    MARK_DIRTY(leaf);

    /* Close the gap */
    SHIFT_KEYS_LEFT(leaf, index, leaf->num_keys - index - 1);
    SHIFT_RECORDS_LEFT(leaf, index, leaf->num_keys - index - 1);

    leaf->num_keys--;

    /* Repair underflow if needed */
    if (IS_UNDERFLOWING(leaf) && !IS_ROOT(leaf)) {
        repair_underflow(tree, leaf);
    }
}

void
clear_recurse(BTree *tree, BTreeNode *node)
{
	if (IS_LEAF(node))
	{
		pager_delete(node->index);
		return;
	}

	uint32_t   i = 0;
	BTreeNode *child = GET_CHILD(node, i);
	while (child != nullptr)
	{
		clear_recurse(tree, child);
		child = GET_CHILD(node, i++);
	}

	pager_delete(node->index);
}

/*
** Clear an entire BTree
**
** Via post order dfs
*/

bool
btree_clear(BTree *tree)
{
	if (0 == tree->root_page_index)
	{
		// unitialised table
		return true;
	}

	clear_recurse(tree, GET_NODE(tree->root_page_index));
	return true;
}



/* ============================================================================
** CURSOR IMPLEMENTATION
**
** Stateful traversal of the B+Tree with support for ordered iteration.
** ============================================================================ */

/*
** Clear cursor state, marking it invalid.
*/
static void cursor_clear(BtCursor* cursor) {
    cursor->leaf_page = 0;
    cursor->leaf_index = 0;
    cursor->state = BT_CURSOR_INVALID;
}

/*
** Move cursor to the first/last key in a subtree.
*/
static bool cursor_move_in_subtree(BtCursor* cursor, BTreeNode* node, bool first) {
    BTree* tree = cursor->tree;

    /* Navigate to leftmost/rightmost leaf */
    while (IS_INTERNAL(node)) {
        uint32_t child_idx = first ? 0 : node->num_keys;
        node = GET_CHILD(node, child_idx);
    }

    if (node->num_keys == 0) {
        cursor->state = BT_CURSOR_INVALID;
        return false;
    }

    cursor->leaf_page = node->index;
    cursor->leaf_index = first ? 0 : (node->num_keys - 1);
    cursor->state = BT_CURSOR_VALID;
    return true;
}

/*
** Move cursor to first or last position in tree.
*/
static bool cursor_move_end(BtCursor* cursor, bool first) {
    BTree* tree = cursor->tree;
    cursor_clear(cursor);

    BTreeNode* root = GET_ROOT();
    if (!root || root->num_keys == 0) {
        cursor->state = BT_CURSOR_INVALID;
        return false;
    }

    return cursor_move_in_subtree(cursor, root, first);
}

/* ============================================================================
** PUBLIC API IMPLEMENTATION
** ============================================================================ */

/*
** Create a new B+Tree with specified key type and record size.
**
** Calculates optimal node capacities based on page size constraints.
** If init is true, creates an empty root node.
*/
BTree btree_create(DataType key, uint32_t record_size, bool init) {
    BTree tree = {0};

    tree.node_key_type = key;
    tree.node_key_size = type_size(key);
    tree.record_size = record_size;

    constexpr uint32_t USABLE_SPACE = PAGE_SIZE - NODE_HEADER_SIZE;

    /* Validate record size */
    if (record_size * MIN_ENTRY_COUNT > USABLE_SPACE) {
        return tree;  /* Invalid configuration */
    }

    /* Calculate leaf node capacity */
    uint32_t leaf_entry_size = tree.node_key_size + record_size;
    uint32_t leaf_max_entries = USABLE_SPACE / leaf_entry_size;

    tree.leaf_max_keys = (MIN_ENTRY_COUNT > leaf_max_entries) ?
                        MIN_ENTRY_COUNT : leaf_max_entries;
    tree.leaf_min_keys = tree.leaf_max_keys / 2;
    tree.leaf_split_index = tree.leaf_max_keys / 2;

    /* Calculate internal node capacity */
    uint32_t child_ptr_size = sizeof(uint32_t);
    uint32_t internal_max_entries = (USABLE_SPACE - child_ptr_size) /
                                   (tree.node_key_size + child_ptr_size);

    /* Ensure balanced splits for internal nodes */
    if (internal_max_entries % 2 == 0) {
        tree.internal_min_keys = (internal_max_entries / 2) - 1;
    } else {
        tree.internal_min_keys = internal_max_entries / 2;
    }

    tree.internal_max_keys = (MIN_ENTRY_COUNT > internal_max_entries) ?
                            MIN_ENTRY_COUNT : internal_max_entries;
    tree.internal_split_index = tree.internal_max_keys / 2;

    /* Create initial root if requested */
    if (init) {
        BTreeNode* root = create_node(&tree, true);
        tree.root_page_index = root->index;
    }

    return tree;
}

/*
** Position cursor at a specific key with comparison operator.
**
** Supports: EQ (exact match), GE, GT, LE, LT
*/
bool bt_cursorseek(BtCursor* cursor, void* key, CompareOp op) {
    BTree* tree = cursor->tree;
    cursor_clear(cursor);

    if (!cursor->tree->root_page_index) {
        cursor->state = BT_CURSOR_INVALID;
        return false;
    }

    /* Find the leaf and position */
    BTreeNode* leaf = find_leaf_for_key(cursor->tree, key);
    uint32_t index = binary_search(cursor->tree, leaf, key);

    cursor->leaf_page = leaf->index;

    /* Check for exact match */
    bool exact = index < leaf->num_keys &&
                type_equals(cursor->tree->node_key_type,
                           GET_KEY_AT(leaf, index), key);

    /* Handle exact match queries */
    if (op == EQ) {
        if (exact) {
            cursor->leaf_index = index;
            cursor->state = BT_CURSOR_VALID;
            return true;
        }
        cursor->state = BT_CURSOR_INVALID;
        return false;
    }

    /* Position cursor for comparison operators */
    cursor->leaf_index = (index >= leaf->num_keys) ?
                        leaf->num_keys - 1 : index;
    cursor->state = BT_CURSOR_VALID;

    /* Navigate to satisfy comparison */
    bool forward = (op == GE || op == GT);

    while (cursor->state == BT_CURSOR_VALID) {
        void* current_key = bt_cursorkey(cursor);
        if (!current_key) break;

        bool satisfied = false;
        switch (op) {
            case GE: satisfied = type_greater_equal(tree->node_key_type,
                                                   current_key, key); break;
            case GT: satisfied = type_greater_than(tree->node_key_type,
                                                  current_key, key); break;
            case LE: satisfied = type_less_equal(tree->node_key_type,
                                                current_key, key); break;
            case LT: satisfied = type_less_than(tree->node_key_type,
                                               current_key, key); break;
            default: break;
        }

        if (satisfied) return true;

        if (!(forward ? bt_cursornext(cursor) :
                       bt_cursorprevious(cursor))) {
            break;
        }
    }

    cursor->state = BT_CURSOR_INVALID;
    return false;
}

/*
** Move cursor to next position in key order.
*/
bool bt_cursornext(BtCursor* cursor) {
    if (cursor->state != BT_CURSOR_VALID) {
        return false;
    }

    BTreeNode* node = GET_NODE(cursor->leaf_page);
    if (!node) {
        cursor->state = BT_CURSOR_INVALID;
        return false;
    }

    cursor->leaf_index++;

    /* Check if we need to move to next leaf */
    if (cursor->leaf_index >= node->num_keys) {
        if (node->next == 0) {
            cursor->state = BT_CURSOR_INVALID;
            return false;
        }

        /* Move to next leaf */
        node = GET_NEXT(node);
        cursor->leaf_page = node->index;
        cursor->leaf_index = 0;

        if (node->num_keys == 0) {
            cursor->state = BT_CURSOR_INVALID;
            return false;
        }
    }

    return true;
}

/*
** Move cursor to previous position in key order.
*/
bool bt_cursorprevious(BtCursor* cursor) {
    if (cursor->state != BT_CURSOR_VALID) {
        return false;
    }

    BTreeNode* node = GET_NODE(cursor->leaf_page);
    if (!node) {
        cursor->state = BT_CURSOR_INVALID;
        return false;
    }

    /* Check if we need to move to previous leaf */
    if (cursor->leaf_index == 0) {
        if (node->previous == 0) {
            cursor->state = BT_CURSOR_INVALID;
            return false;
        }

        /* Move to previous leaf */
        node = GET_PREV(node);
        cursor->leaf_page = node->index;

        if (node->num_keys == 0) {
            cursor->state = BT_CURSOR_INVALID;
            return false;
        }

        cursor->leaf_index = node->num_keys - 1;
    } else {
        cursor->leaf_index--;
    }

    return true;
}

/*
** Additional cursor operations follow the same patterns...
** (bt_cursorfirst, bt_cursorlast, bt_cursorinsert,
**  bt_cursordelete, bt_cursorupdate, etc.)
*/

bool bt_cursorfirst(BtCursor* cursor) {
    return cursor_move_end(cursor, true);
}

bool bt_cursorlast(BtCursor* cursor) {
    return cursor_move_end(cursor, false);
}

bool bt_cursoris_valid(BtCursor* cursor) {
    return cursor->state == BT_CURSOR_VALID;
}

void* bt_cursorkey(BtCursor* cursor) {
    BTree* tree = cursor->tree;
    if (cursor->state != BT_CURSOR_VALID) return nullptr;

    BTreeNode* node = GET_NODE(cursor->leaf_page);
    if (!node || cursor->leaf_index >= node->num_keys) return nullptr;

    return GET_KEY_AT(node, cursor->leaf_index);
}

void* bt_cursorrecord(BtCursor* cursor) {
    BTree* tree = cursor->tree;
    if (cursor->state != BT_CURSOR_VALID) return nullptr;

    BTreeNode* node = GET_NODE(cursor->leaf_page);
    if (!node || cursor->leaf_index >= node->num_keys) return nullptr;

    return GET_RECORD_AT(node, cursor->leaf_index);
}

bool bt_cursorinsert(BtCursor* cursor, void* key, void* record) {
    if (bt_cursorseek(cursor, key, EQ)) {
        return false;  /* Key already exists */
    }

    insert_element(cursor->tree, key, record);
    return true;
}

bool bt_cursordelete(BtCursor* cursor) {
    if (cursor->state != BT_CURSOR_VALID) return false;

    void* key = bt_cursorkey(cursor);
    if (!key) return false;

    BTreeNode* node = GET_NODE(cursor->leaf_page);
    delete_element(cursor->tree, node, cursor->leaf_index);

    /* Adjust cursor position after deletion */
    node = GET_NODE(cursor->leaf_page);
    if (!node) {
        cursor->state = BT_CURSOR_INVALID;
        return true;
    }

    if (cursor->leaf_index >= node->num_keys) {
        if (node->num_keys > 0) {
            cursor->leaf_index = node->num_keys - 1;
        } else {
            cursor->state = BT_CURSOR_INVALID;
        }
    }

    return true;
}

bool bt_cursorupdate(BtCursor* cursor, void* record) {
    if (cursor->state != BT_CURSOR_VALID) return false;

    pager_mark_dirty(cursor->leaf_page);
    void* data = bt_cursorrecord(cursor);
    memcpy(data, record, cursor->tree->record_size);
    return true;
}
bool
bt_cursorhas_next(BtCursor *cursor)
{
	if (bt_cursornext(cursor))
	{
		bt_cursorprevious(cursor);
		return true;
	}
	return false;
}

bool
bt_cursorhas_previous(BtCursor *cursor)
{
	if (bt_cursorprevious(cursor))
	{
		bt_cursornext(cursor);
		return true;
	}
	return false;
}







/*NOCOVER_START*/

#include <unordered_set>

#define ASSERT_PRINT(condition, tree)                                                                                  \
	if (!(condition))                                                                                                  \
	{                                                                                                                  \
		btree_print(tree);                                                                                             \
		assert(condition);                                                                                             \
	}

// Validation result structure to pass information up the recursion
struct ValidationResult
{
	uint32_t   depth;
	uint8_t	  *min_key;
	uint8_t	  *max_key;
	BTreeNode *leftmost_leaf;
	BTreeNode *rightmost_leaf;
};

// Forward declaration
static ValidationResult
validate_node_recursive(BTree *tree, BTreeNode *node, uint32_t expected_parent, void *parent_min_bound,
						void *parent_max_bound, std::unordered_set<uint32_t> &visited);

// Main validation function
void
btree_validate(BTree *tree_ptr)
{

	BTree *tree = tree_ptr;
	ASSERT_PRINT(tree_ptr != nullptr, tree_ptr);

	// Empty tree is valid
	if (tree_ptr->root_page_index == 0)
	{
		return;
	}

	BTreeNode *root = GET_ROOT();
	ASSERT_PRINT(root != nullptr, tree_ptr);

	// Root specific checks
	ASSERT_PRINT(IS_ROOT(root), tree_ptr); // Root has no parent
	ASSERT_PRINT(root->index == tree_ptr->root_page_index, tree_ptr);

	// Track visited nodes to detect cycles
	std::unordered_set<uint32_t> visited;

	// Validate tree recursively
	ValidationResult result = validate_node_recursive(tree, root, 0, nullptr, nullptr, visited);

	// If tree has data, verify leaf chain integrity
	if (IS_LEAF(root) && root->num_keys > 0)
	{
		// Single leaf root should have no siblings
		ASSERT_PRINT(root->next == 0, tree_ptr);
		ASSERT_PRINT(root->previous == 0, tree_ptr);
	}
	else if (IS_INTERNAL(root))
	{
		// Verify complete leaf chain by walking it
		BTreeNode					*first_leaf = result.leftmost_leaf;
		BTreeNode					*current = first_leaf;
		std::unordered_set<uint32_t> leaf_visited;

		ASSERT_PRINT(current->previous == 0, tree_ptr); // First leaf has no previous

		while (current)
		{
			ASSERT_PRINT(IS_LEAF(current), tree_ptr);
			ASSERT_PRINT(leaf_visited.find(current->index) == leaf_visited.end(), tree_ptr); // No cycles in leaf chain
			leaf_visited.insert(current->index);

			if (current->next != 0)
			{
				BTreeNode *next = GET_NEXT(current);
				ASSERT_PRINT(next != nullptr, tree_ptr);
				ASSERT_PRINT(next->previous == current->index, tree_ptr); // Bidirectional link integrity
				current = next;
			}
			else
			{
				ASSERT_PRINT(current == result.rightmost_leaf, tree_ptr); // Last leaf matches rightmost
				break;
			}
		}
	}
}
static ValidationResult
validate_node_recursive(BTree *tree, BTreeNode *node, uint32_t expected_parent, void *parent_min_bound,
						void *parent_max_bound, std::unordered_set<uint32_t> &visited)
{
	ASSERT_PRINT(node != nullptr, tree);

	// Check for cycles
	ASSERT_PRINT(visited.find(node->index) == visited.end(), tree);
	visited.insert(node->index);

	// Verify parent pointer
	ASSERT_PRINT(node->parent == expected_parent, tree);

	// Check key count constraints
	uint32_t max_keys = GET_MAX_KEYS(node);
	uint32_t min_keys = GET_MIN_KEYS(node);

	ASSERT_PRINT(node->num_keys <= max_keys, tree);

	// Non-root nodes must meet minimum
	if (expected_parent != 0)
	{
		ASSERT_PRINT(node->num_keys >= min_keys, tree);
	}
	else
	{
		// Root can have fewer, but not zero (unless tree is being cleared)
		if (node->num_keys == 0)
		{
			ASSERT_PRINT(IS_LEAF(node), tree); // Only leaf root can be empty during deletion
		}
	}

	// Validate key ordering and bounds
	void *prev_key = nullptr;
	void *first_key = nullptr;
	void *last_key = nullptr;

	for (uint32_t i = 0; i < node->num_keys; i++)
	{
		void *current_key = GET_KEY_AT(node, i);

		if (i == 0)
		{
			first_key = current_key;
		}
		if (i == node->num_keys - 1)
		{
			last_key = current_key;
		}

		if (prev_key)
		{
			ASSERT_PRINT(type_less_than(tree->node_key_type, prev_key, current_key), tree); // prev < current
		}

		// Check bounds from parent
		if (parent_min_bound)
		{
			ASSERT_PRINT(type_greater_equal(tree->node_key_type, current_key, parent_min_bound), tree);
		}
		if (parent_max_bound)
		{
			ASSERT_PRINT(type_less_than(tree->node_key_type, current_key, parent_max_bound), tree);
		}
		prev_key = current_key;
	}

	ValidationResult result;
	result.min_key = (uint8_t *)first_key;
	result.max_key = (uint8_t *)last_key;

	if (IS_LEAF(node))
	{
		result.depth = 0;
		result.leftmost_leaf = node;
		result.rightmost_leaf = node;

		// Validate leaf data exists
		void *records = GET_RECORD_DATA(node);
		ASSERT_PRINT(records != nullptr, tree);

		// Verify leaf chain pointers are valid page indices or 0
		if (node->next != 0)
		{
			ASSERT_PRINT(node->next != node->index, tree); // No self-reference
			BTreeNode *next = GET_NEXT(node);
			ASSERT_PRINT(next != nullptr, tree);
			ASSERT_PRINT(IS_LEAF(next), tree);
		}
		if (node->previous != 0)
		{
			ASSERT_PRINT(node->previous != node->index, tree); // No self-reference
			BTreeNode *prev = GET_PREV(node);
			ASSERT_PRINT(prev != nullptr, tree);
			ASSERT_PRINT(IS_LEAF(prev), tree);
		}
	}
	else
	{
		// Internal node validation
		uint32_t *children = GET_CHILDREN(node);
		ASSERT_PRINT(children != nullptr, tree);

		uint32_t   child_depth = UINT32_MAX;
		BTreeNode *leftmost_leaf = nullptr;
		BTreeNode *rightmost_leaf = nullptr;

		// Internal nodes have num_keys + 1 children
		for (uint32_t i = 0; i <= node->num_keys; i++)
		{
			ASSERT_PRINT(children[i] != 0, tree);			// No null children
			ASSERT_PRINT(children[i] != node->index, tree); // No self-reference

			BTreeNode *child = GET_CHILD(node, i);
			ASSERT_PRINT(child != nullptr, tree);

			// Determine bounds for this child
			void *child_min = (i == 0) ? parent_min_bound : GET_KEY_AT(node, i - 1);
			void *child_max = (i == node->num_keys) ? parent_max_bound : GET_KEY_AT(node, i);

			ValidationResult child_result =
				validate_node_recursive(tree, child, node->index, child_min, child_max, visited);

			// All children must have same depth
			if (child_depth == UINT32_MAX)
			{
				child_depth = child_result.depth;
				leftmost_leaf = child_result.leftmost_leaf;
			}
			else
			{
				ASSERT_PRINT(child_depth == child_result.depth, tree);
			}

			// Track rightmost leaf
			rightmost_leaf = child_result.rightmost_leaf;

			// Verify key bounds match child contents
			if (child_result.min_key && i > 0)
			{
				// First key in child >= separator key before it
				void *separator = GET_KEY_AT(node, i - 1);
				ASSERT_PRINT(type_greater_equal(tree->node_key_type, child_result.min_key, separator), tree);
			}
			if (child_result.max_key && i < node->num_keys)
			{
				// Last key in child < separator key after it
				void *separator = GET_KEY_AT(node, i);
				ASSERT_PRINT(type_less_equal(tree->node_key_type, child_result.max_key, separator), tree);
			}
		}

		result.depth = child_depth + 1;
		result.leftmost_leaf = leftmost_leaf;
		result.rightmost_leaf = rightmost_leaf;

		// Internal nodes should not have leaf chain pointers
		ASSERT_PRINT(node->next == 0, tree);
		ASSERT_PRINT(node->previous == 0, tree);
	}

	return result;
}

// Add this to bplustree.cpp

#include <queue>
#include <iomanip>

// Helper to print a single key based on type
static void
print_key(BTree *tree, void *key)
{
	if (!key)
	{
		printf("NULL");
		return;
	}
	type_print(tree->node_key_type, key);
}

// Main B+Tree print function
void
btree_print(BTree *tree_ptr)
{
	BTree *tree = tree_ptr;
	if (!tree_ptr || tree_ptr->root_page_index == 0)
	{
		printf("B+Tree: EMPTY\n");
		return;
	}

	printf("====================================\n");
	printf("B+Tree Structure (BFS)\n");
	printf("====================================\n");
	printf("Root: page_%u\n", tree_ptr->root_page_index);
	printf("Key type: %s, Record size: %u bytes\n", type_name(tree_ptr->node_key_size), tree_ptr->record_size);
	printf("Internal: max_keys=%u, min_keys=%u\n", tree_ptr->internal_max_keys, tree_ptr->internal_min_keys);
	printf("Leaf: max_keys=%u, min_keys=%u\n", tree_ptr->leaf_max_keys, tree_ptr->leaf_min_keys);
	printf("------------------------------------\n\n");

	// BFS traversal using two queues (current level and next level)
	std::queue<uint32_t> current_level;
	std::queue<uint32_t> next_level;

	current_level.push(tree_ptr->root_page_index);
	uint32_t depth = 0;

	while (!current_level.empty())
	{
		printf("LEVEL %u:\n", depth);
		printf("--------\n");

		while (!current_level.empty())
		{
			uint32_t page_index = current_level.front();
			current_level.pop();

			BTreeNode *node = GET_NODE(page_index);
			if (!node)
			{
				printf("  ERROR: Cannot read page %u\n", page_index);
				continue;
			}

			// Print node header
			printf("  Node[page_%u]:\n", node->index);
			printf("    Type: %s\n", IS_LEAF(node) ? "LEAF" : "INTERNAL");
			printf("    Parent: %s\n", IS_ROOT(node) ? "ROOT" : ("page_" + std::to_string(node->parent)).c_str());
			printf("    Keys(%u): [", node->num_keys);

			// Print keys
			for (uint32_t i = 0; i < node->num_keys; i++)
			{
				if (i > 0)
					printf(", ");
				print_key(tree_ptr, GET_KEY_AT(node, i));
			}
			printf("]\n");

			// Print children for internal nodes
			if (IS_INTERNAL(node))
			{
				uint32_t *children = GET_CHILDREN(node);
				printf("    Children(%u): [", node->num_keys + 1);
				for (uint32_t i = 0; i <= node->num_keys; i++)
				{
					if (i > 0)
						printf(", ");
					printf("page_%u", children[i]);

					// Add children to next level queue
					next_level.push(children[i]);
				}
				printf("]\n");
			}
			else
			{
				// Print leaf chain info
				printf("    Leaf chain: ");
				if (node->previous != 0)
				{
					printf("prev=page_%u", node->previous);
				}
				else
				{
					printf("prev=NULL");
				}
				printf(", ");
				if (node->next != 0)
				{
					printf("next=page_%u", node->next);
				}
				else
				{
					printf("next=NULL");
				}
				printf("\n");
			}

			printf("\n");
		}

		// Move to next level
		if (!next_level.empty())
		{
			std::swap(current_level, next_level);
			depth++;
		}
	}

	// Print leaf chain traversal for verification
	printf("====================================\n");
	printf("Leaf Chain Traversal:\n");
	printf("------------------------------------\n");

	// Find leftmost leaf
	BTreeNode *current = GET_ROOT();
	while (IS_INTERNAL(current))
	{
		current = GET_CHILD(current, 0);
		if (!current)
		{
			printf("ERROR: Cannot find leftmost leaf\n");
			return;
		}
	}

	printf("  ");
	uint32_t leaf_count = 0;
	while (current)
	{
		if (leaf_count > 0)
			printf(" -> ");
		printf("page_%u", current->index);

		// Safety check for cycles
		if (++leaf_count > 1000)
		{
			printf("\n  ERROR: Possible cycle detected in leaf chain!\n");
			break;
		}

		current = GET_NEXT(current);
	}
	printf("\n");
	printf("  Total leaves: %u\n", leaf_count);
	printf("====================================\n\n");
}

// Compact tree printer (single line per node)
void
btree_print_compact(BTree *tree_ptr)
{
	BTree *tree = tree_ptr;
	if (!tree_ptr || tree_ptr->root_page_index == 0)
	{
		printf("B+Tree: EMPTY\n");
		return;
	}

	printf("B+Tree (page:type:keys:parent):\n");

	std::queue<uint32_t> queue;
	std::queue<uint32_t> levels;

	queue.push(tree_ptr->root_page_index);
	levels.push(0);

	uint32_t current_level = 0;

	while (!queue.empty())
	{
		uint32_t page_index = queue.front();
		uint32_t level = levels.front();
		queue.pop();
		levels.pop();

		if (level != current_level)
		{
			printf("\n");
			current_level = level;
		}

		BTreeNode *node = GET_NODE(page_index);
		if (!node)
			continue;

		// Print: page_index:type:num_keys:parent
		printf("[%u:%c:%u:%u] ", node->index, IS_LEAF(node) ? 'L' : 'I', node->num_keys, node->parent);

		// Add children to queue
		if (IS_INTERNAL(node))
		{
			uint32_t *children = GET_CHILDREN(node);
			for (uint32_t i = 0; i <= node->num_keys; i++)
			{
				queue.push(children[i]);
				levels.push(level + 1);
			}
		}
	}
	printf("\n");
}
/*NOCOVER_END*/
