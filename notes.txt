
INTRO:

Hi everyone, a couple of months ago I set myself a challange to to build an SQL engine from scratch,
and because of the lack of examples out there, I've decided to make a video about it. The source code that we'll
be going through is linked below, so please feel free to play around it with it.

First things first let's see the final product.

Show different selects, and updates, inserts,
A few demo programs, like like




OVERVIEW:
- most of the the diagrams in the readme
- get rid of test is 50





PAGER:
- nodes on disk
- other types of relations aka blobs
- where page size comes from aka read one-byte



BTREE:

- node data is in a block that we have to interpret at runtime
- use the pager to do gets




[Diagrams before and after op via prints]
- Show binary search tree, white board math logs
- Given that we're working with 4kb+ pages, b+trees are more efficient, show whiteboard math
- Show b+tree visual
- node raw data layout
- my btree has fixed size rows, you can do more do save spaced
- child/data access pointer math. shift keys
- swap with root
- no point walking through it
- clear recurse
- validate and print, first get 1 root leaf node working
- coverage
- show btree print out and coverage

[Tuple oriented view]

BLOB:
- If we need store large amounts of data that wouldn't, sqlite has the concept of overflow pages
- I've done something similar.



PARSER:

COMPILER:
NEED remove bools that make no sense like should_update


CATALOG/SEMANTIC

VM:
- Need diagrams to explain interpreting tuples, from tuples to records







KEY CONCEPTS:

PAGES

B+TREES

CURSORS
