


┌─────────────────────────────────────────────────────────────┐
│                        SQL Query                            │
│                  "SELECT * FROM users"                      │
└────────────────────┬────────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────────┐
│                    PARSER (parser.cpp)                      │
│                                                             │
│  Lexical Analysis → Tokens → Recursive Descent → AST        │
│                                                             │
│  Output: Abstract Syntax Tree                               │
└────────────────────┬────────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────────┐
│              SEMANTIC ANALYZER (semantic.cpp)               │
│                                                             │
│  Validate tables, columns, types           ┌──────────────┐ │
│  Resolve names to IDs                      │   CATALOG    │ │
│  Type checking                             │ (catalog.cpp)│ │
│                                            │              │ │
│  Output: Validated & Annotated AST         │ Schema cache │ │
└────────────────────┬───────────────────────│ Table defs   │ │
                     │                       │ Column types │ │
                     ▼                       │ Index info   │ │
┌────────────────────────────────────────────└──────────────┘─│
│                  COMPILER (compile.cpp)                     │
│                                                             │
│  Transform AST → VM bytecode                                │
│  Resolve table/column IDs to storage locations              │
│  Select access methods (sequential scan vs index)           │
│                                                             │
│  Output: Bytecode Program + Execution Metadata              │
└────────────────────┬────────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────────┐
│              VIRTUAL MACHINE (vm.cpp)                       │
│                                                             │
│  Register-based VM                                          │
│  Executes bytecode instructions                             │
│  Interfaces with storage via cursors                        │
│                                                             │
└────────────────────┬────────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────────┐
│                    STORAGE LAYER                            │
│  ┌──────────────────────────────────────────────────────┐   │
│  │           CURSOR ABSTRACTION                         │   │
│  │     [Table, Index, and In-Memory cursors]            │   │
│  └──────────────────┬───────────────────────────────────┘   │
│                     │                                       │
│  ┌──────────────────▼───────────────────────────────────┐   │
│  │     B+TREE (btree.cpp)  │  BLOB STORE (blob.cpp)     │   │
│  └──────────────────┬──────────────┬────────────────────┘   │
│                     │              │                        │
│  ┌──────────────────▼──────────────▼────────────────────┐   │
│  │                 PAGER (pager.cpp)                    │   │
│  │         [Page cache, WAL, Free page management]      │   │
│  └──────────────────┬───────────────────────────────────┘   │
│                     │                                       │
│  ┌──────────────────▼───────────────────────────────────┐   │
│  │              OS LAYER (os_layer.cpp)                 │   │
│  └──────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────┘


// pipeline example

┌─────────────────────────────────────────────────────────────────────┐
│ SQL: SELECT * FROM users WHERE user_id > 50;                        │
└──────────────────────┬──────────────────────────────────────────────┘
                       ▼
┌─────────────────────────────────────────────────────────────────────┐
│ PARSER - Abstract Syntax Tree                                       │
├─────────────────────────────────────────────────────────────────────┤
│ Statement type: SELECT                                              │
│ Table: users                                                        │
│ Columns: * (all)                                                    │
│ WHERE:                                                              │
│   BinaryOp                                                          │
│   ├── op: GT (>)                                                    │
│   ├── left: Column("user_id")                                       │
│   └── right: Literal(50, TYPE_U32)                                  │
└──────────────────────┬──────────────────────────────────────────────┘
                       ▼
┌─────────────────────────────────────────────────────────────────────┐
│ SEMANTIC ANALYZER - Annotated AST                                   │
├─────────────────────────────────────────────────────────────────────┤
│ ✓ Table 'users' exists with 5 columns:                              │
│   [0] user_id (U32) - PRIMARY KEY                                   │
│   [1] username (CHAR32)                                             │
│   [2] email (CHAR32)                                                │
│   [3] age (U32)                                                     │
│   [4] city (CHAR16)                                                 │
│                                                                     │
│ ✓ Column 'user_id' is column index 0                                │
│ ✓ Literal 50 compatible with U32                                    │
└──────────────────────┬──────────────────────────────────────────────┘
                       ▼
┌─────────────────────────────────────────────────────────────────────┐
│ COMPILER - VM Bytecode Program                                      │
├─────────────────────────────────────────────────────────────────────┤
│ PC[ 0] OPEN cursor=0 ctx=users_btree                                │
│ PC[ 1] LOAD R[0] <- 50 (U32)           # Seek key                   │
│ PC[ 2] SEEK cursor=0 key=R[0] op=GT -> R[1]  # Find first > 50      │
│ PC[ 3] JUMPIF R[1] FALSE -> PC[13]     # Exit if not found          │
│        ┌─── LOOP START ───┐                                         │
│ PC[ 4] │ COLUMN cursor=0 col=0 -> R[2]  # Extract all columns       │
│ PC[ 5] │ COLUMN cursor=0 col=0 -> R[5]                              │
│ PC[ 6] │ COLUMN cursor=0 col=1 -> R[6]                              │
│ PC[ 7] │ COLUMN cursor=0 col=2 -> R[7]                              │
│ PC[ 8] │ COLUMN cursor=0 col=3 -> R[8]                              │
│ PC[ 9] │ COLUMN cursor=0 col=4 -> R[9]                              │
│ PC[10] │ RESULT R[5..9]                # Output row                 │
│ PC[11] │ STEP cursor=0 forward -> R[1] # Next record                │
│ PC[12] └ GOTO PC[3]                     # Continue loop             │
│ PC[13] CLOSE cursor=0                                               │
│ PC[14] HALT exit_code=0                                             │
└──────────────────────┬──────────────────────────────────────────────┘
                       ▼
┌─────────────────────────────────────────────────────────────────────┐
│ VIRTUAL MACHINE EXECUTION                                           │
├─────────────────────────────────────────────────────────────────────┤
│ Registers:                    Cursor State:                         │
│ R[0] = 50                     ┌─────────────────┐                   │
│ R[1] = true (found)           │ Cursor #0       │                   │
│ R[2] = 51 (current user_id)   │ ┌─────────────┐ │                   │
│ R[3] = 50                     │ │ position    ├─┼──► [51,Bob,...]   │
│ R[4] = true (51 > 50)         │ └─────────────┘ │                   │
│ R[5..9] = row data            │ Tree: users     │                   │
│                               │ Leaf: page_5    │                   │
│                               │ Index: 2        │                   │
│                               └─────────────────┘                   │
└──────────────────────┬──────────────────────────────────────────────┘
                       ▼
┌─────────────────────────────────────────────────────────────────────┐
│ B+TREE STRUCTURE                                                    │
├─────────────────────────────────────────────────────────────────────┤
│ Root Page (Internal Node)                                           │
│ ┌────────────────────────────────────────┐                          │
│ │ Keys: [30, 60, 90]                     │                          │
│ │ Children: [p3, p5, p7, p9]             │                          │
│ └────────┬──────┬──────┬──────┬──────────┘                          │
│          ▼      ▼      ▼      ▼                                     │
│      ┌────┐ ┌────┐ ┌────┐ ┌────┐                                    │
│      │ p3 │ │ p5 │ │ p7 │ │ p9 │  Leaf Pages                        │
│      └────┘ └────┘ └────┘ └────┘                                    │
│                                                                     │
│ Page 3 (Leaf): [1,Alice] [15,Charlie] [29,Eve]                      │
│                                                                     │
│                                                                     │
│ Page 5 (Leaf): [31,Frank] [42,Grace] [51,Bob] [59,Helen]            │
│                                         ↑                           │
│                                    cursor here                      │
│                                                                     │
│ Page 7 (Leaf): [61,Ivan] [75,Julia] [89,Kevin]                      │
│                                                                     │
│                                                                     │
│ Page 9 (Leaf): [91,Laura] [95,Mike] [99,Nancy]                      │
│                                                                     │
│                                                                     │
│ Leaf Chain: p3 ↔ p5 ↔ p7 ↔ p9                                       │
└─────────────────────────────────────────────────────────────────────┘

EXECUTION TRACE:
1. SEEK positions cursor at first key > 50 (finds 51 in page 5)
2. Loop reads [51,Bob,...] and outputs via RESULT
3. STEP moves cursor to [59,Helen,...]
4. Continue until end of tree
5. Output: All users with user_id > 50












































┌─────────────────────────────────────────────────────────────────┐
│                        LOGICAL VIEW (SQL)                        │
│  Table: users                                                    │
│  ┌─────┬───────────────┬──────────────┬─────┐                  │
│  │ id  │     email     │     name     │ age │                  │
│  ├─────┼───────────────┼──────────────┼─────┤                  │
│  │  1  │ alice@ex.com  │    Alice     │  25 │                  │
│  │  2  │  bob@ex.com   │     Bob      │  30 │                  │
│  └─────┴───────────────┴──────────────┴─────┘                  │
│                                                                  │
│  "Show me all users" → Rows with named columns                  │
└─────────────────────────────────────────────────────────────────┘
                              ↕
┌─────────────────────────────────────────────────────────────────┐
│                   VM VIEW (Cursor + TupleFormat)                 │
│  ┌──────────────────────────────────────────────┐              │
│  │ VmCursor[0] → BtCursor {                      │              │
│  │   leaf_page: 42                               │              │
│  │   leaf_index: 0                               │              │
│  │   state: VALID                                │              │
│  │ }                                             │              │
│  └──────────────────────────────────────────────┘              │
│                                                                  │
│  CursorContext {                                                 │
│    layout: TupleFormat {                                        │
│      key_type: TYPE_U32        // Column 0 (id)                │
│      columns: [TYPE_U32, TYPE_CHAR32, TYPE_CHAR16, TYPE_U16]   │
│      offsets: [0, 32, 48]      // Offsets within record        │
│      record_size: 50           // Total record bytes           │
│    }                                                            │
│  }                                                              │
│                                                                  │
│  OP_Column(cursor, 0) → Read key as TYPE_U32                    │
│  OP_Column(cursor, 1) → Read record[0:32] as TYPE_CHAR32        │
│  OP_Column(cursor, 2) → Read record[32:48] as TYPE_CHAR16       │
│  OP_Column(cursor, 3) → Read record[48:50] as TYPE_U16          │
└─────────────────────────────────────────────────────────────────┘
                              ↕
┌─────────────────────────────────────────────────────────────────┐
│                    B-TREE VIEW (Key-Value Store)                 │
│  BTreeNode (page 42) {                                          │
│    flags: IS_LEAF                                               │
│    num_keys: 2                                                  │
│    parent: 15                                                   │
│    prev: 41                                                     │
│    next: 43                                                     │
│                                                                  │
│    ┌─────────────────────────────────────────┐                 │
│    │ Keys (stored separately):                │                 │
│    │   keys[0]: 0x00000001  (4 bytes)        │                 │
│    │   keys[1]: 0x00000002  (4 bytes)        │                 │
│    └─────────────────────────────────────────┘                 │
│                                                                  │
│    ┌─────────────────────────────────────────┐                 │
│    │ Records (opaque byte arrays):            │                 │
│    │   records[0]: [50 bytes of raw data...] │                 │
│    │   records[1]: [50 bytes of raw data...] │                 │
│    └─────────────────────────────────────────┘                 │
│  }                                                              │
│                                                                  │
│  B-tree only knows:                                             │
│  • How to compare keys (via DataType)                          │
│  • Size of keys (4 bytes) and records (50 bytes)               │
│  • Nothing about record internals                               │
└─────────────────────────────────────────────────────────────────┘
                              ↕
┌─────────────────────────────────────────────────────────────────┐
│                      PAGER VIEW (Raw Pages)                      │
│  Page 42:                                                        │
│  ┌──────────────────────────────────────────────────────┐      │
│  │[0x00] Page Index (4 bytes): 0x0000002A              │      │
│  │[0x04] Raw bytes (4064 bytes):                       │      │
│  │       0x01 0x02 0x00 0x0F 0x29 0x2B ...            │      │
│  │       [node header][keys][records][unused]...       │      │
│  └──────────────────────────────────────────────────────┐      │
│                                                                  │
│  Pager only knows:                                              │
│  • Pages are PAGE_SIZE bytes                                         │
│  • First 4 bytes = page index                                   │
│  • Remaining PAGE_SIZE - 4 bytes = usable space                          │
│  • Nothing about content structure                              │
└─────────────────────────────────────────────────────────────────┘










DISK-BASED TREE WITH PARTIAL MEMORY RESIDENCE
    ═══════════════════════════════════════════════════════════════════════

    PAGER'S ARRAY-LIKE ABSTRACTION
    ────────────────────────────────────────────────────────────────────

    Database File (Logical View):
    ┌────┬────┬────┬────┬────┬────┬────┬────┬────┬────┬────┬────┬────┐
    │ 0  │ 1  │ 2  │ 3  │ 4  │ 5  │ 6  │ 7  │ 8  │ 9  │ 10 │ 11 │... │
    ├────┼────┼────┼────┼────┼────┼────┼────┼────┼────┼────┼────┼────┤
    │Root│Node│Node│Node│Node│Node│Node│Node│Node│Node│Node│Node│    │
    │Page│    │    │    │    │    │    │    │    │    │    │    │    │
    └────┴────┴────┴────┴────┴────┴────┴────┴────┴────┴────┴────┴────┘
    Each slot = 1 PAGE_SIZE (1024 bytes)

    The file is just an array of fixed-size pages!
    Page Index = File Offset / PAGE_SIZE


    TREE NODE "POINTERS" ARE INDICES
    ════════════════════════════════════════════════════════════════════

    Traditional In-Memory Tree:          Disk-Based Tree:
    ─────────────────────────            ────────────────
    struct Node {                        struct btree_node {
        Key keys[N];                         uint32_t index;      // self
        Node* children[N+1]; ← pointers      uint32_t parent;     // index!
    };                                       uint32_t children[]; // indices!
                                         };

    child = node->children[i]            child = GET_NODE(node->children[i])
            ↓                                     ↓
    Direct memory access                  pager_get(page_index)
                                                ↓
                                         Returns cached or loads from disk


    MULTIPLE TREES IN SAME FILE
    ════════════════════════════════════════════════════════════════════

    Database File Layout:
    ┌─────────────────────────────────────────────────────────────────┐
    │Page│     Tree A Pages        │    Tree B Pages    │ Free Pages │
    │ 0  │ 1   2   3   4   5   6  │ 7   8   9  10  11 │ 12  13  14 │
    ├────┼─────────────────────────┼────────────────────┼────────────┤
    │Root│ A₁  A₂  A₃  A₄  A₅  A₆ │ B₁  B₂  B₃  B₄  B₅│ F₁  F₂  F₃│
    └────┴─────────────────────────┴────────────────────┴────────────┘
          ↑                         ↑                     ↑
    Tree A: root_page_index = 1    Tree B: root = 7    Free list

    btree* tree_A = btree_open(TYPE_U32, TYPE_NULL, 1);  // Root at page 1
    btree* tree_B = btree_open(TYPE_U64, varchar(50), 7); // Root at page 7

    Each tree only knows about its own pages via parent/child indices!


    PARTIAL MEMORY RESIDENCE (WORKING SET)
    ════════════════════════════════════════════════════════════════════

    Example: Searching Tree A for key 42

    Step 1: Start at root (page 1)
    ────────────────────────────────
    Disk:  [0][1][2][3][4][5][6][7][8][9]...
               ↑
    Cache: [Page 1 data]

    GET_ROOT() → pager_get(1) → Loaded into cache


    Step 2: Binary search in root, follow child[2] = page 3
    ────────────────────────────────────────────────────────
    Disk:  [0][1][2][3][4][5][6][7][8][9]...
               ↑     ↑
    Cache: [Page 1][Page 3]

    GET_CHILD(node, 2) → GET_NODE(3) → pager_get(3) → Loaded


    Step 3: Binary search in page 3, follow child[0] = page 5
    ──────────────────────────────────────────────────────────
    Disk:  [0][1][2][3][4][5][6][7][8][9]...
               ↑     ↑     ↑
    Cache: [Page 1][Page 3][Page 5]  ← Only path to key is loaded!

    Pages 2, 4, 6 remain on disk - never touched for this query


    B+TREE NODE STRUCTURE IN PAGE
    ════════════════════════════════════════════════════════════════════

    Internal Node (Page 3):
    ┌──────────────────────────────────────────────────────────────┐
    │ Header (24 bytes)              │ Data Area (1000 bytes)      │
    ├────────┬────────┬──────┬──────┼──────────────┬──────────────┤
    │index: 3│parent:1│next:0│keys:2│ Keys         │ Children     │
    │        │        │prev:0│leaf:0│ [30][60]     │ [5][2][6]    │
    └────────┴────────┴──────┴──────┴──────────────┴──────────────┘
                                          ↑             ↑
                                     Sorted keys   Page indices

    Leaf Node (Page 5):
    ┌──────────────────────────────────────────────────────────────┐
    │ Header (24 bytes)              │ Data Area (1000 bytes)      │
    ├────────┬────────┬──────┬──────┼──────────────┬──────────────┤
    │index: 5│parent:3│next:2│keys:3│ Keys         │ Records      │
    │        │        │prev:0│leaf:1│ [10][20][25] │ [R₁][R₂][R₃] │
    └────────┴────────┴──────┴──────┴──────────────┴──────────────┘
                         ↑                              ↑
                    Leaf chain              Actual data records


    TRAVERSAL WITH PAGE INDICES
    ════════════════════════════════════════════════════════════════════

    Code:                           What Actually Happens:
    ─────                           ─────────────────────
    find_leaf_for_key(tree, 42)
    {
      node = GET_ROOT()             node = pager_get(tree->root_page_index)
                                           = pager_get(1)
                                           → Returns pointer to cached page 1

      while (IS_INTERNAL(node))     while (node->is_leaf == 0)
      {
        idx = binary_search(...)    // Find child index = 2

        node = GET_CHILD(node,idx)  node = GET_NODE(children[2])
                                          = GET_NODE(3)
                                          = pager_get(3)
                                          → Returns pointer to cached page 3
      }
      return node                   // Returns pointer to leaf in cache
    }

    The tree code thinks it's following pointers,
    but it's actually loading pages by index!


    RANGE SCAN USING LEAF CHAIN
    ════════════════════════════════════════════════════════════════════

    Leaf Chain (linked by page indices):
    ┌────────┐    ┌────────┐    ┌────────┐    ┌────────┐
    │ Page 5 │───→│ Page 2 │───→│ Page 6 │───→│ Page 4 │
    │ [10-25]│ 2  │ [31-45]│ 6  │ [61-75]│ 4  │ [80-99]│ 0
    └────────┘    └────────┘    └────────┘    └────────┘
         ↑             ↑             ↑             ↑
    node->next    node->next    node->next    node->next

    Range scan from 20 to 70:
    1. Find leaf for 20 → Page 5
    2. Scan Page 5: get [20,25]
    3. Follow chain: GET_NEXT(node) → pager_get(2) → Page 2
    4. Scan Page 2: get [31,45]
    5. Follow chain: GET_NEXT(node) → pager_get(6) → Page 6
    6. Scan Page 6: get [61] and stop at 75

    Only pages in the range are loaded into memory!


    TRANSACTION & CRASH CONSISTENCY
    ════════════════════════════════════════════════════════════════════

    Split operation creating new nodes:

    Before:                     After:
    Page 3 (full)              Page 3 + new Page 15

    1. new_node = create_node() → pager_new() → Returns page 15
    2. Modify both nodes with new data
    3. pager_mark_dirty(3) and pager_mark_dirty(15)
    4. On commit: Both written atomically
    5. On crash: Journal ensures both changes applied or neither

    The tree always sees a consistent view!


    KEY INSIGHTS
    ════════════════════════════════════════════════════════════════════

    1. FILE AS ARRAY: The database file is just a flat array of pages.
       Trees impose structure via index references.

    2. INDICES AS POINTERS: Where in-memory trees use pointers,
       disk trees use page indices. GET_NODE() bridges this gap.

    3. LAZY LOADING: Only accessed nodes are loaded. A million-node
       tree might only need 3-4 pages in memory for a point query.

    4. CACHE TRANSPARENCY: Tree algorithms don't know about caching.
       They just call pager_get() and always get valid pointers.

    5. MULTIPLE STRUCTURES: Different trees/indexes can coexist in
       the same file, each starting from different root pages.

    6. CRASH SAFETY: Page-level atomicity + journaling ensures trees
       are never corrupted, even mid-operation.




AST → BYTECODE COMPILATION PIPELINE
    ═══════════════════════════════════════════════════════════════════════

    SQL TO AST (Parser)
    ────────────────────────────────────────────────────────────────────

    Input: "SELECT name, age FROM users WHERE age > 21 ORDER BY name"

    Tokenization:
    ┌──────┬──────┬──────┬──────┬───────┬──────┬──────┬─────┬────┬────┐
    │SELECT│ name │  ,   │ age  │ FROM  │users │WHERE │ age │ >  │ 21 │...
    └──────┴──────┴──────┴──────┴───────┴──────┴──────┴─────┴────┴────┘

    AST Generation:
    ┌─────────────────────────────────┐
    │       SelectStmt                │
    ├─────────────────────────────────┤
    │ table_name: "users"             │
    │ columns: ["name", "age"]        │
    │ order_by_column: "name"         │
    │ where_clause: ───────────┐      │
    └───────────────────────────┼─────┘
                                ▼
                        ┌─────────────┐
                        │  EXPR_BINARY│
                        │   op: GT    │
                        ├─────────────┤
                        │ left    right│
                        └──┬───────┬──┘
                           ▼       ▼
                    ┌──────────┐ ┌──────────┐
                    │EXPR_COLUMN│ │EXPR_LITERAL│
                    │"age"     │ │21         │
                    └──────────┘ └──────────┘


    SEMANTIC ANALYSIS (Adds Type Info)
    ════════════════════════════════════════════════════════════════════

    Before Semantic:                  After Semantic:
    ─────────────────                 ───────────────
    EXPR_COLUMN                       EXPR_COLUMN
    ├─ column_name: "age"            ├─ column_name: "age"
    └─ sem: {                        └─ sem: {
         resolved_type: NULL              resolved_type: TYPE_U32
         column_index: -1                 column_index: 1
         table: nullptr                   table: &users_relation
       }                                }


    PROGRAMBUILDER ABSTRACTION LAYER
    ════════════════════════════════════════════════════════════════════

    High-Level API:                   Generated Bytecode:
    ───────────────                    ──────────────────
    prog.begin_transaction()      →    [OP_Begin]

    cursor = prog.open_cursor(    →    [OP_Open, C0, users_btree]
        from_structure(users))

    at_end = prog.first(cursor)   →    [OP_Rewind, C0, R0, false]

    loop = prog.begin_while(at_end)    [OP_JumpIf, R0, @end]
    {                                   [@loop:]
        age = prog.get_column(     →   [OP_Column, C0, 1, R1]
            cursor, 1)

        limit = prog.load(         →   [OP_Load, R2, TYPE_U32, 21]
            TYPE_U32, 21)

        test = prog.gt(age, limit) →   [OP_Test, R3, R1, R2, GT]

        if_block = prog.begin_if(test) [OP_JumpIf, R3, @skip, false]
        {
            name = prog.get_column( →  [OP_Column, C0, 0, R4]
                cursor, 0)
            prog.result(name, 2)    →   [OP_Result, R4, 2]
        }
        prog.end_if(if_block)          [@skip:]

        prog.next(cursor, at_end)  →   [OP_Step, C0, R0, true]
        prog.goto_label("loop")    →   [OP_Goto, @loop]
    }
    prog.end_while(loop)               [@end:]

    prog.close_cursor(cursor)     →    [OP_Close, C0]
    prog.commit_transaction()      →    [OP_Commit]
    prog.halt()                    →    [OP_Halt, 0]


    REGISTER ALLOCATION
    ════════════════════════════════════════════════════════════════════

    RegisterAllocator State:
    ┌──────────────────────────────────────────────────────────────┐
    │ next_reg: 5                                                  │
    │ high_water: 5                                                │
    │ scope_stack: [0, 1] ← Nested scopes for loops/conditions     │
    └──────────────────────────────────────────────────────────────┘

    Allocation Pattern:
    R0: at_end flag (loop control)
    R1: age column value
    R2: literal 21
    R3: comparison result
    R4: name column value

    Scoped allocation allows register reuse in different branches!


    LABEL RESOLUTION (Two-Pass)
    ════════════════════════════════════════════════════════════════════

    Pass 1: Emit with Symbolic Labels
    ──────────────────────────────────
    Instructions:                    Labels Map:
    [0] OP_Begin                    (empty)
    [1] OP_Open C0
    [2] OP_Rewind C0 R0
    [3] OP_JumpIf R0 "end"  ←─┐
    [4] OP_Column C0 1 R1      │     "loop" → 4
    [5] OP_Load R2 21          │     "skip" → 9
    [6] OP_Test R3 R1 R2 GT    │     "end"  → 11
    [7] OP_JumpIf R3 "skip" ←──┤
    [8] OP_Column C0 0 R4      │
    [9] OP_Result R4 2         │
    [10] OP_Step C0 R0         │
    [11] OP_Goto "loop"    ←───┤
    [12] OP_Close C0           │
    [13] OP_Commit             │
    [14] OP_Halt               │
                               │
    Pass 2: Resolve Labels     │
    ──────────────────────     │
    [3] OP_JumpIf R0 11  ←─────┘
    [7] OP_JumpIf R3 9   ←──────┘
    [11] OP_Goto 4       ←──────┘


    EXPRESSION COMPILATION (Recursive)
    ════════════════════════════════════════════════════════════════════

    compile_expr(age > 21 AND name = 'John'):

                        AND
                       /   \
                   GT         EQ
                  /  \       /  \
               age   21   name  'John'

    Traversal:
    1. compile_expr(AND)
       ├─ left = compile_expr(GT)
       │  ├─ left = compile_expr(age)
       │  │  └─ prog.get_column(cursor, 1) → R1
       │  ├─ right = compile_expr(21)
       │  │  └─ prog.load(TYPE_U32, 21) → R2
       │  └─ prog.gt(R1, R2) → R3
       │
       ├─ right = compile_expr(EQ)
       │  ├─ left = compile_expr(name)
       │  │  └─ prog.get_column(cursor, 0) → R4
       │  ├─ right = compile_expr('John')
       │  │  └─ prog.load(TYPE_CHAR32, "John") → R5
       │  └─ prog.eq(R4, R5) → R6
       │
       └─ prog.logic_and(R3, R6) → R7


    OPTIMIZATION: PRIMARY KEY SEEK
    ════════════════════════════════════════════════════════════════════

    WHERE id = 42 Detection:

    is_pk_lookup() checks:
    ┌─────────────────────┐
    │ 1. Binary op?       │ → Yes (=)
    │ 2. Column is PK?    │ → Yes (id)
    │ 3. Other is literal?│ → Yes (42)
    └─────────────────────┘
            ↓
    Optimized Code Path:
    ────────────────────
    Normal:                      Optimized:
    prog.first(cursor)          key = prog.load(42)
    loop:                       found = prog.seek(cursor, key, EQ)
      check each row...         if (found)
      if matches...               emit result
    goto loop

    O(n) scan → O(log n) seek!


    CONTROL FLOW PATTERNS
    ════════════════════════════════════════════════════════════════════

    While Loop:                     If Statement:
    ──────────                      ─────────────
    test = ...                      test = ...
    [@loop_end] ← JumpIf test       [@else] ← JumpIf !test
    [@loop_body:]                   [@then:]
      ... body ...                    ... then body ...
      update test                     Goto @end
      Goto @loop_body               [@else:]
    [@loop_end:]                      ... else body ...
                                    [@end:]


    Nested Scopes:
    ─────────────
    while (outer) {          Scope Stack:
      R1 = ...               [0]      ← base
      if (inner) {           [0, 2]   ← push for while
        R2 = ...             [0, 2, 3] ← push for if
      }                      [0, 2]   ← pop
      R2 = ... // can reuse!
    }                        [0]      ← pop


    CURSOR CONTEXT CREATION
    ════════════════════════════════════════════════════════════════════

    from_structure(users_table):
    ┌────────────────────────┐
    │ CursorContext          │
    ├────────────────────────┤
    │ type: BPLUS            │
    │ storage.tree: &btree   │
    │ layout: TupleFormat {  │
    │   columns: [           │
    │     {TYPE_U32, 0},     │  // id
    │     {TYPE_U32, 4},     │  // age
    │     {TYPE_CHAR32, 8}   │  // name
    │   ]                    │
    │ }                      │
    └────────────────────────┘

    This tells the VM how to interpret raw tree records!


    KEY DESIGN INSIGHTS
    ════════════════════════════════════════════════════════════════════

    1. BUILDER PATTERN: ProgramBuilder provides high-level abstractions
       that hide bytecode complexity. Clean separation of concerns.

    2. REGISTER MACHINE: Virtual registers instead of stack-based VM
       allows better optimization and clearer generated code.

    3. LABEL-BASED JUMPS: Human-readable labels during compilation,
       resolved to PC offsets in final pass.

    4. SCOPED ALLOCATION: Register reuse within scopes reduces
       register pressure without complex liveness analysis.

    5. CURSOR ABSTRACTION: SQL operations map to cursor primitives
       (open, seek, step, get_column) hiding storage details.

    6. TYPE PRESERVATION: Types flow from parser → semantic → compiler
       → VM, ensuring type safety throughout.




CURSOR: STATEFUL TREE TRAVERSAL
    ═══════════════════════════════════════════════════════════════════════

    CURSOR ABSTRACTION LAYER
    ────────────────────────────────────────────────────────────────────

    VmCursor (Unified Interface)
    ┌─────────────────────────────┐
    │ type: BPLUS | RED_BLACK     │
    │ layout: TupleFormat         │
    │ cursor: union {             │
    │   bt_cursor bptree;         │──→ Persistent B+Tree
    │   et_cursor mem;            │──→ Ephemeral Red-Black
    │ }                           │
    └─────────────────────────────┘
            ↓
    Polymorphic Operations:
    - vmcursor_seek(cursor, key, op)
    - vmcursor_step(cursor, forward)
    - vmcursor_get_key/record(cursor)

    Same interface, different storage!


    CURSOR STATE (B+Tree Example)
    ════════════════════════════════════════════════════════════════════

    bt_cursor Structure:
    ┌──────────────────────┐
    │ tree: btree*         │──→ Points to tree
    │ leaf_page: 42        │──→ Current leaf page index
    │ leaf_index: 3        │──→ Position within leaf
    │ state: VALID         │──→ Cursor validity
    └──────────────────────┘

    Tree Structure:                    Cursor Position:
                 [Root:1]                     ↓
                /    |    \            (Not stored - we're at leaf!)
            [7]    [15]    [42]  ←── leaf_page = 42
           /  \     |      /  \       leaf_index = 3
         Leaves: [···] [···] [K₀|K₁|K₂|K₃|K₄]
                                        ↑
                               Cursor points here


    RANGE QUERY: SEEK + STEP vs REPEATED SEEKS
    ════════════════════════════════════════════════════════════════════

    Query: SELECT * FROM users WHERE age >= 25 AND age <= 35

    Inefficient (Repeated Seeks):         Efficient (Seek + Step):
    ──────────────────────────────         ────────────────────────

    for age in 25..35:                    cursor.seek(25, GE)
      cursor.seek(age, EQ)  ← O(log n)    while cursor.valid:
      if found:                             age = cursor.get_key()
        emit_result()                       if age > 35: break
                                           emit_result()
    Total: 11 × O(log n)                   cursor.next()  ← O(1)
           Tree traversals!
                                          Total: 1 × O(log n) + k × O(1)
                                                 One traversal + linear scan!


    Visual Comparison:
    ─────────────────
    Repeated Seeks (11 tree traversals):

         Root                Root                Root
          ↓                   ↓                   ↓
       Internal            Internal            Internal
          ↓                   ↓                   ↓
        Leaf               Leaf                Leaf
         25                 26                  27...

    Seek + Step (1 traversal, then leaf chain):

         Root
          ↓
       Internal
          ↓
        Leaf ──→ Leaf ──→ Leaf ──→ Leaf
         25      26      27      28...

    Uses leaf chain for O(1) navigation!


    CURSOR NAVIGATION OPERATIONS
    ════════════════════════════════════════════════════════════════════

    Operation     B+Tree Implementation        Red-Black Implementation
    ─────────     ─────────────────────        ────────────────────────

    REWIND(start) Walk left edges to           In-order to minimum
                  first leaf
                  ┌─────┐                      ┌─────┐
                  │Root │                      │Root │
                  └──┬──┘                      └──┬──┘
                     ↓                            ↓
                  ┌─────┐                      ┌─────┐
                  │Node │                      │Node │
                  └──┬──┘                      └──┬──┘
                     ↓                            ↓
                  [First]                      [Min]

    NEXT()        if (leaf_index < num_keys-1) if (has_right_child)
                    leaf_index++                 go to leftmost of right
                  else                         else
                    follow leaf->next            go up to unvisited parent

                  Current leaf                 Current node
                  [A|B|C|D|E]                     (C)
                      ↑   ↑                      /   \
                    index index+1              (B)   (D)
                                                ↑     ↑
                                            current  next

    SEEK(GT,30)   Binary search to leaf,      Binary search in tree,
                  then linear scan             position at first > 30

                  Find leaf with 30,               (40)
                  scan for first > 30             /    \
                  [25|30|31|35]                (20)    (50)
                       ↑  ↑                     /  \    /  \
                      30  31 ← Found         (15)(30)(45)(60)
                                                    ↑
                                                  Found


    LEAF CHAIN NAVIGATION (B+Tree Optimization)
    ════════════════════════════════════════════════════════════════════

    Leaf Level with Bidirectional Chain:

         Internal Nodes (ignored during scan)
              /        |         \
    ┌────────────┐ ┌────────────┐ ┌────────────┐ ┌────────────┐
    │ Leaf A     │←→│ Leaf B     │←→│ Leaf C     │←→│ Leaf D     │
    │ [1,5,9]    │  │ [12,15,18] │  │ [22,28,30] │  │ [35,40,45] │
    │ prev: 0    │  │ prev: A    │  │ prev: B    │  │ prev: C    │
    │ next: B    │  │ next: C    │  │ next: D    │  │ next: 0    │
    └────────────┘  └────────────┘  └────────────┘  └────────────┘

    Range Query [15,35]:
    1. Seek(15) → Lands in Leaf B at index 1
    2. Emit 15, 18
    3. cursor->next → Leaf C (via page index, O(1))
    4. Emit 22, 28, 30
    5. cursor->next → Leaf D
    6. Emit 35, stop (40 > 35)

    Never revisit internal nodes during scan!


    UNIFIED CURSOR INTERFACE IN VM
    ════════════════════════════════════════════════════════════════════

    VM Instruction          B+Tree Storage           Red-Black Storage
    ──────────────          ──────────────           ─────────────────

    OP_Open C0 context  →   bt_cursor.tree =     →   et_cursor.tree =
                           context->storage.tree     et_create(...)

    OP_Rewind C0 R0    →   bt_cursorfirst()     →   et_cursor_first()
                           R0 = valid?               R0 = valid?

    OP_Seek C0 K GT R1 →   bt_cursorseek(       →   et_cursor_seek(
                             cursor, K, GT)           cursor, K, GT)
                           R1 = found?               R1 = found?

    OP_Step C0 R2      →   bt_cursornext()      →   et_cursor_next()
                           R2 = still_valid?         R2 = still_valid?

    OP_Column C0 2 R3  →   bt_cursorrecord()    →   et_cursor_record()
                           extract column 2          extract column 2
                           into R3                   into R3

    The VM doesn't know or care about storage implementation!


    CURSOR LIFECYCLE IN QUERY
    ════════════════════════════════════════════════════════════════════

    SELECT * FROM orders WHERE total >= 100 AND total <= 500

    Bytecode:                     Cursor State:
    ─────────                     ─────────────
    [OP_Open C0 orders]           state: INVALID

    [OP_Seek C0 100 GE R0]       Traverse to leaf
                                 state: VALID
                                 leaf_page: 23
                                 leaf_index: 7

    [OP_JumpIf R0 @found]        (cursor unchanged)

    [@found:]
    [OP_Column C0 1 R1]          Read at current position
                                 (cursor unchanged)

    [OP_Test R1 500 GT R2]       (cursor unchanged)
    [OP_JumpIf R2 @done]

    [OP_Result R1]               (cursor unchanged)

    [OP_Step C0 R3]              Move to next entry
                                 leaf_index: 8
                                 OR
                                 leaf_page: 24, leaf_index: 0

    [OP_JumpIf R3 @found]        Loop back if valid

    [@done:]
    [OP_Close C0]                state: INVALID


    KEY DESIGN INSIGHTS
    ════════════════════════════════════════════════════════════════════

    1. STATEFUL POSITION: Cursor maintains position between operations,
       avoiding repeated tree traversals from root.

    2. LEAF CHAIN OPTIMIZATION: B+tree cursors use leaf-level links
       for O(1) sequential access during range scans.

    3. STORAGE POLYMORPHISM: Same cursor interface works for both
       persistent (B+tree) and ephemeral (red-black) storage.

    4. ITERATOR PATTERN: Cursors provide iterator semantics (first,
       next, valid) making loops natural in bytecode.

    5. ZERO-COPY ACCESS: Cursors return pointers directly into
       page cache (B+tree) or node memory (red-black).

    6. SEEK MODES: Support for different comparison ops (EQ, GT, GE,
       LT, LE) enables efficient range query starting points.
